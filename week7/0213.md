## 스프링 프레임워크
자바에서 거의 표준으로 사용하는 프레임워크이고,

자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다.

### 스프링의 특징
- 경량 컨테이너로서, Spring Bean을 직접 관리한다.
- IoC(제어 역전)
  - 사용자가 아니라 Spring 에서 필요에 따라 사용자의 코드를 호출한다.
- AOP(관점 지향 프로그래밍)을 지원한다.


### 프레임워크와 라이브러리
웹 서버를 개발하다 보면 CRUD와 같은 비슷한 작업을 계속해서 반복하게 되는데,


프레임워크는 그런 반복되는 기능을 생산성 있게 구현할 수 있도록 도와주고, 

비즈니스 로직에 집중할 수 있도록 해준다.


라이브러리는 단순 활용가능한 도구들의 집합을 의미한다.

프레임워크와 라이브러리의 차이점은 **제어 흐름에 대한 주도성**의 차이가 있다.

프레임워크는 전체적은 흐름을 프레임워크가 지고 있으면 그 안에 필요한 코드를 구현하는 반면,

라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓴다.


### BOM
Bill of Materials의 약자로,
스프링에 구성되는 많은 모듈들의 버전을 관리해주는 역할을 한다.

### 다형성
```java
public class GreetingService {
  private Greeter greeter;
// Greeter 는 부모클래스 or 인터페이스 일 수 있다.
}
```
Java에서 변수는 부모 클래스 타입이나 인터페이스 타입에 할당될 수 있다.

참조 변수의 메소드를 호출하면 실제 구현 객체의 메소드가 실행된다.

동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 결정한다.

## IoC
Inversion of Control, 제어의 역전을 뜻한다.

개발자는 제어권이 없고, 제어권을 프레임워크가 가지게 되어 제어가 역전되었다는 것을 IoC라고 한다.

IoC의 관점에서, 개발자는 코드의 흐름이나 객체 생성에 관련된 코드를 직접 작성하지 않는다.

또한 프레임워크는 개발자가 짜놓은 설정을 보고 객체를 생성하고 코드가 동작하는 순서를 결정하여 실행한다.

## ApplicationContext
스프링 컨테이너를 의미하고, Spring Bean들을 생성, 삭제와 의존성을 관리해주는 역할을 한다.

### BeanFactory와 ApplicationContext
BeanFactory가 스프링 빈을 관리하고 조회하는 역할을 담당하는 스프링 컨테이너의 최상위 인터페이스이지만,

어플리케이션을 개발할 때는 빈을 관리하고 조회하는 기능과 함께 수 많은 부가기능이 필요하기 때문에

BeanFactory를 상속받고 부가 기능이 추가되어있는 ApplicationContext를 주로 스프링 컨테이너라고 한다.

## Bean 생명주기
DB 커넥션 풀 생성과 같은 작업을 할 때는 객체의 초기화 시점에 주로 진행한다.
스프링에서는 객체 생성 -> 의존관계 주입 의 라이프사이클을 가지고, 의존관계 주입이 모두 완료된 시점을

콜백을 통해 알려준다.

### 스프링 빈의 이벤트 라이프사이클

스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

스프링은 InitializingBean, DisposableBean의 인터페이스를 통한 콜백,

설정 정보에 초기화, 소멸 메서드 지정을 통한 콜백,

@PostConstruct, @PreDestroy 어노테이션을 이용한 콜백을 지원한다.

주로 어노테이션을 통한 콜백을 사용하고,

코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod 를
사용한다.

## 싱글톤 컨테이너
요청을 할 때마다 객체를 새로 생성하고 소멸하면 메모리 낭비가 심하기 때문에,

객체를 딱 1개만 생성하고 공유하도록 설계하도록 나온 패턴이 싱글톤 패턴이다.

그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 하기에,

private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.

```java
public class SingletonService {
  //1. static 영역에 객체를 딱 1개만 생성해둔다.
  private static final SingletonService instance = new SingletonService();

  //2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
  public static SingletonService getInstance() {
    return instance;
  }

  //3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
  private SingletonService() {
  }

  public void logic() {
    System.out.println("싱글톤 객체 로직 호출");
  }
}
```

여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 

싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안되고, 무상태(stateless)로 설계해야 한다.

필드 대신 파라미터, ThreadLocal 등을 사용하여 무상태로 설계한다.

## 빈 스코프

스프링은 다음과 같은 다양한 빈 스코프를 지원한다.
- 싱글톤
  - 기본 스코프로, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. 
- 프로토타입
  - 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
- 웹 관련 스코프 
  - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다. 
  
  - session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
  
  - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

### 프로토타입 스코프
조회했을 때 항상 같은 인스턴스를 반환하는 싱글톤 빈과 달리 프로토타입 스코프를 스프링에 조회하면

항상 새로운 인스턴스를 생성해서 반환해준다.

**프로토타입 빈은 생성하고, 의존관계 주입, 초기화까지만 처리된다.**

그 이후에는 스프링 컨테이너가 관리하지 않기 때문에 종료 메서드가 호출되지 않고,

프로토타입 빈을 받은 클라이언트가 직접 관리해야 한다.

또 싱글톤 빈에 의존관계로 프로토타입 빈이 주입되면,

싱글톤은 생성 시점에만 의존관계 주입을 받기 때문에 한번 생선된 프로토타입 빈이 그대로 사용되게 된다.

이럴 땐 ObjectProvider 등을 사용해서 스프링 빈을 받아올 때마다 프로토타입 빈이 생성되도록 만든다.
